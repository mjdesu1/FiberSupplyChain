import express, { Request, Response } from 'express';
import { supabase } from '../config/supabase';

const router = express.Router();

// Submit sales report (Farmer)
router.post('/submit-report', async (req: Request, res: Response) => {
  try {
    const { farmer_id, report_month, transactionDetails } = req.body;
    
    // Validate required fields
    if (!farmer_id) {
      return res.status(400).json({
        success: false,
        message: 'Farmer ID is required'
      });
    }
    
    if (!transactionDetails.buyerCompanyName || transactionDetails.buyerCompanyName.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'Buyer company name is required'
      });
    }
    
    // Validate abaca type is provided
    if (!transactionDetails.abacaType || transactionDetails.abacaType.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'Abaca type/grade is required'
      });
    }
    
    // Use the abaca type as provided (no default)
    const abacaType = transactionDetails.abacaType.trim();
    
    // Validate and set payment method with default
    const validPaymentMethods = ['cash', 'bank_transfer', 'check', 'credit'];
    const paymentMethod = transactionDetails.paymentMethod && validPaymentMethods.includes(transactionDetails.paymentMethod)
      ? transactionDetails.paymentMethod
      : 'cash';
    
    // Validate and set payment status with default
    const validPaymentStatuses = ['paid', 'pending', 'partial'];
    const paymentStatus = transactionDetails.paymentStatus && validPaymentStatuses.includes(transactionDetails.paymentStatus)
      ? transactionDetails.paymentStatus
      : 'paid';
    
    console.log('ðŸ“ Processing sales report:', {
      farmer_id,
      abacaType,
      buyerCompanyName: transactionDetails.buyerCompanyName,
      paymentMethod,
      paymentStatus
    });
    
    // Extract comprehensive transaction data from the form
    const reportData = {
      farmer_id,
      report_month,
      // 1. Basic Transaction Info
      transaction_reference: null, // Auto-generated by database
      sale_date: transactionDetails.dateOfSale,
      buyer_company_name: transactionDetails.buyerCompanyName.trim(),
      // 2. Product Details
      abaca_type: abacaType, // Use validated abaca type
      quantity_sold: parseFloat(transactionDetails.quantitySold) || 0,
      unit_price: parseFloat(transactionDetails.unitPrice) || 0,
      total_amount: parseFloat(transactionDetails.totalAmount) || 0,
      // 3. Payment Details
      payment_method: paymentMethod, // Use validated payment method
      payment_status: paymentStatus, // Use validated payment status
      // 4. Logistics / Delivery
      delivery_location: transactionDetails.deliveryLocation || null,
      shipping_fee: parseFloat(transactionDetails.shippingFee) || 0,
      // 5. Remarks / Notes
      quality_notes: transactionDetails.qualityNotes || null,
      other_comments: transactionDetails.otherComments || null,
      // Administrative
      submitted_at: new Date().toISOString()
    };
    
    console.log('ðŸ“¦ Final report data:', reportData);
    
    // Insert comprehensive sales report
    const { data: reportResult, error: reportError } = await supabase
      .from('sales_reports')
      .insert(reportData)
      .select('report_id')
      .single();
    
    if (reportError) {
      console.error('âŒ Supabase error:', reportError);
      console.error('âŒ Report data that failed:', reportData);
      throw reportError;
    }
    
    res.json({
      success: true,
      message: 'Sales report submitted successfully',
      reportId: reportResult.report_id
    });
    
  } catch (error) {
    console.error('Error submitting sales report:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit sales report',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get all sales reports (Admin/SuperAdmin)
router.get('/reports', async (req: Request, res: Response) => {
  try {
    const { status, period } = req.query;
    
    // Build query with filters - fetch sales reports without joins
    let query = supabase
      .from('sales_reports')
      .select(`
        report_id,
        farmer_id,
        report_month,
        sale_date,
        buyer_company_name,
        abaca_type,
        quantity_sold,
        unit_price,
        total_amount,
        payment_method,
        payment_status,
        delivery_location,
        shipping_fee,
        quality_notes,
        other_comments,
        status,
        submitted_at,
        reviewed_at,
        reviewed_by,
        rejection_reason
      `)
      .order('submitted_at', { ascending: false });
    
    // Apply status filter
    if (status) {
      query = query.eq('status', status);
    }
    
    // Apply period filter
    if (period) {
      const currentDate = new Date();
      let dateFilter: string;
      
      switch (period) {
        case 'current_month':
          dateFilter = currentDate.toISOString().slice(0, 7); // YYYY-MM
          break;
        case 'last_month':
          const lastMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
          dateFilter = lastMonth.toISOString().slice(0, 7);
          break;
        default:
          dateFilter = currentDate.toISOString().slice(0, 7);
      }
      
      query = query.eq('report_month', dateFilter);
    }
    
    const { data: reports, error } = await query;
    
    if (error) {
      throw error;
    }
    
    // Fetch farmer names separately to avoid join issues
    const farmerIds = [...new Set(reports?.map(r => r.farmer_id) || [])];
    const { data: farmers } = await supabase
      .from('farmers')
      .select('farmer_id, full_name')
      .in('farmer_id', farmerIds);
    
    // Create farmer lookup map
    const farmerMap = (farmers || []).reduce((acc: any, farmer) => {
      acc[farmer.farmer_id] = farmer.full_name;
      return acc;
    }, {});
    
    // Add farmer names to reports
    const reportsWithFarmers = (reports || []).map(report => ({
      ...report,
      farmers: { full_name: farmerMap[report.farmer_id] || 'Unknown Farmer' }
    }));
    
    res.json({
      success: true,
      reports: reportsWithFarmers
    });
    
  } catch (error: any) {
    console.error('Error fetching sales reports:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch sales reports',
      error: error.message
    });
  }
});

// Get sales analytics (Admin/SuperAdmin)
router.get('/analytics', async (req: Request, res: Response) => {
  try {
    const { period } = req.query;
    
    // Get approved sales reports without joins
    const { data: reports, error } = await supabase
      .from('sales_reports')
      .select('farmer_id, total_amount, quantity_sold')
      .eq('status', 'approved');
    
    if (error) {
      throw error;
    }
    
    // Calculate analytics from the data
    const uniqueFarmers = new Set(reports.map(r => r.farmer_id)).size;
    const totalRevenue = reports.reduce((sum, r) => sum + (r.total_amount || 0), 0);
    const totalQuantity = reports.reduce((sum, r) => sum + (r.quantity_sold || 0), 0);
    const totalTransactions = reports.length; // Each report is now one transaction
    const averageRevenuePerFarmer = uniqueFarmers > 0 ? totalRevenue / uniqueFarmers : 0;
    
    // Get farmer names for top performer calculation
    const farmerIds = [...new Set(reports.map(r => r.farmer_id))];
    const { data: farmersList } = await supabase
      .from('farmers')
      .select('farmer_id, full_name')
      .in('farmer_id', farmerIds);
    
    const farmerMap = (farmersList || []).reduce((acc: any, farmer) => {
      acc[farmer.farmer_id] = farmer.full_name;
      return acc;
    }, {});
    
    // Find top performing farmer
    const farmerRevenues = reports.reduce((acc: any, r) => {
      if (!acc[r.farmer_id]) {
        acc[r.farmer_id] = { revenue: 0, name: farmerMap[r.farmer_id] || 'Unknown' };
      }
      acc[r.farmer_id].revenue += r.total_amount || 0;
      return acc;
    }, {});
    
    const topFarmer = Object.values(farmerRevenues)
      .sort((a: any, b: any) => b.revenue - a.revenue)[0] as any;
    
    res.json({
      success: true,
      analytics: {
        totalFarmers: uniqueFarmers,
        totalRevenue: totalRevenue,
        totalQuantity: totalQuantity,
        totalTransactions: totalTransactions,
        averageRevenuePerFarmer: averageRevenuePerFarmer,
        topPerformingFarmer: topFarmer?.name || 'No data',
        mostPopularGrade: 'Tuxy', // Default since we simplified
        monthlyGrowth: 0 // Can be calculated later
      }
    });
    
  } catch (error: any) {
    console.error('Error fetching sales analytics:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch sales analytics',
      error: error.message
    });
  }
});

// Get farmer performance data (Admin/SuperAdmin)
router.get('/farmers-performance', async (req: Request, res: Response) => {
  try {
    // Get sales reports without joins
    const { data: reports, error } = await supabase
      .from('sales_reports')
      .select(`
        farmer_id,
        report_id,
        total_amount,
        quantity_sold,
        unit_price,
        submitted_at
      `)
      .eq('status', 'approved');
    
    if (error) {
      throw error;
    }
    
    // Get farmer names separately
    const farmerIds = [...new Set(reports.map(r => r.farmer_id))];
    const { data: farmerData } = await supabase
      .from('farmers')
      .select('farmer_id, full_name')
      .in('farmer_id', farmerIds);
    
    const farmerMap = (farmerData || []).reduce((acc: any, farmer) => {
      acc[farmer.farmer_id] = farmer.full_name;
      return acc;
    }, {});
    
    // Group by farmer and calculate performance metrics
    const farmerPerformance = reports.reduce((acc: any, report) => {
      const farmerId = report.farmer_id;
      if (!acc[farmerId]) {
        acc[farmerId] = {
          farmer_id: farmerId,
          farmer_name: farmerMap[farmerId] || 'Unknown',
          total_reports: 0,
          total_revenue: 0,
          total_quantity: 0,
          total_transactions: 0,
          prices: [],
          last_report_date: null,
          top_grade: 'Tuxy'
        };
      }
      
      acc[farmerId].total_reports += 1;
      acc[farmerId].total_revenue += report.total_amount || 0;
      acc[farmerId].total_quantity += report.quantity_sold || 0;
      acc[farmerId].total_transactions += 1; // Each report is one transaction now
      
      if (report.unit_price) {
        acc[farmerId].prices.push(report.unit_price);
      }
      
      if (!acc[farmerId].last_report_date || report.submitted_at > acc[farmerId].last_report_date) {
        acc[farmerId].last_report_date = report.submitted_at;
      }
      
      return acc;
    }, {});
    
    // Calculate average prices and format results
    const farmersPerformanceList = Object.values(farmerPerformance).map((farmer: any) => ({
      ...farmer,
      average_price: farmer.prices.length > 0 
        ? farmer.prices.reduce((sum: number, price: number) => sum + price, 0) / farmer.prices.length 
        : 0,
      prices: undefined // Remove the prices array from response
    })).sort((a: any, b: any) => b.total_revenue - a.total_revenue);
    
    res.json({
      success: true,
      farmers: farmersPerformanceList
    });
    
  } catch (error: any) {
    console.error('Error fetching farmer performance:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch farmer performance',
      error: error.message
    });
  }
});

// Get farmer's own reports
router.get('/farmer-reports/:farmerId', async (req: Request, res: Response) => {
  try {
    const { farmerId } = req.params;
    
    const { data: reports, error } = await supabase
      .from('sales_reports')
      .select(`
        report_id,
        report_month,
        buyer_company_name,
        abaca_type,
        quantity_sold,
        unit_price,
        total_amount,
        payment_method,
        payment_status,
        delivery_location,
        shipping_fee,
        quality_notes,
        other_comments,
        status,
        submitted_at,
        reviewed_at,
        rejection_reason
      `)
      .eq('farmer_id', farmerId)
      .order('report_month', { ascending: false })
      .order('submitted_at', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    res.json({
      success: true,
      reports: reports
    });
    
  } catch (error: any) {
    console.error('Error fetching farmer reports:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch farmer reports',
      error: error.message
    });
  }
});

// Update full sales report (Admin/SuperAdmin)
router.put('/reports/:reportId', async (req: Request, res: Response) => {
  try {
    const { reportId } = req.params;
    const { buyer_company_name, quantity_sold, unit_price, total_amount, status, reviewed_by } = req.body;
    
    const updateData: any = {};
    
    // Only update fields that are provided
    if (buyer_company_name !== undefined) updateData.buyer_company_name = buyer_company_name;
    if (quantity_sold !== undefined) updateData.quantity_sold = parseFloat(quantity_sold);
    if (unit_price !== undefined) updateData.unit_price = parseFloat(unit_price);
    if (total_amount !== undefined) updateData.total_amount = parseFloat(total_amount);
    if (status !== undefined) {
      updateData.status = status;
      updateData.reviewed_by = reviewed_by;
      updateData.reviewed_at = new Date().toISOString();
    }
    
    const { data: report, error } = await supabase
      .from('sales_reports')
      .update(updateData)
      .eq('report_id', reportId)
      .select()
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') {
        return res.status(404).json({
          success: false,
          message: 'Sales report not found'
        });
      }
      throw error;
    }
    
    res.json({
      success: true,
      message: 'Sales report updated successfully',
      report: report
    });
    
  } catch (error: any) {
    console.error('Error updating report:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update report',
      error: error.message
    });
  }
});

// Approve/Reject sales report (Admin/SuperAdmin)
router.put('/reports/:reportId/status', async (req: Request, res: Response) => {
  try {
    const { reportId } = req.params;
    const { status, reviewed_by, rejection_reason } = req.body;
    
    const { data: report, error } = await supabase
      .from('sales_reports')
      .update({
        status,
        reviewed_by,
        reviewed_at: new Date().toISOString(),
        rejection_reason: rejection_reason || null
      })
      .eq('report_id', reportId)
      .select()
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') {
        return res.status(404).json({
          success: false,
          message: 'Sales report not found'
        });
      }
      throw error;
    }
    
    res.json({
      success: true,
      message: `Sales report ${status} successfully`,
      report: report
    });
    
  } catch (error: any) {
    console.error('Error updating report status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update report status',
      error: error.message
    });
  }
});

// Delete sales report (Farmer - only pending reports)
router.delete('/delete-report/:reportId', async (req: Request, res: Response) => {
  try {
    const { reportId } = req.params;
    
    // First check if report exists and is pending
    const { data: existingReport, error: fetchError } = await supabase
      .from('sales_reports')
      .select('status')
      .eq('report_id', reportId)
      .single();
    
    if (fetchError || !existingReport) {
      return res.status(404).json({
        success: false,
        message: 'Sales report not found'
      });
    }
    
    // Only allow deletion of pending reports
    if (existingReport.status !== 'pending') {
      return res.status(403).json({
        success: false,
        message: 'Cannot delete approved or rejected reports'
      });
    }
    
    // Delete the report
    const { error: deleteError } = await supabase
      .from('sales_reports')
      .delete()
      .eq('report_id', reportId);
    
    if (deleteError) {
      throw deleteError;
    }
    
    res.json({
      success: true,
      message: 'Sales report deleted successfully'
    });
    
  } catch (error: any) {
    console.error('Error deleting report:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete report',
      error: error.message
    });
  }
});

export default router;
